package tls

import (
	"bytes"
	"crypto/rsa"
	"crypto/x509"
	"os"

	"github.com/pkg/errors"

	"github.com/openshift/installer/pkg/asset"
)

// AppendParentChoice dictates whether the parent's cert is to be added to the
// cert.
type AppendParentChoice bool

const (
	// AppendParent indicates that the parent's cert should be added.
	AppendParent AppendParentChoice = true
	// DoNotAppendParent indicates that the parent's cert should not be added.
	DoNotAppendParent AppendParentChoice = false
)

// CertKeyInterface contains a private key and the associated cert.
type CertKeyInterface interface {
	// Cert returns the certificate.
	Cert() []byte
	// Key returns the private key.
	Key() []byte
}

// CertKey contains the private key and the cert that's
// signed by the parent CA.
type CertKey struct {
	keyRaw  []byte
	certRaw []byte

	files []*asset.File
}

// Cert returns the certificate.
func (c *CertKey) Cert() []byte {
	return c.certRaw
}

// Key returns the private key.
func (c *CertKey) Key() []byte {
	return c.keyRaw
}

// Generate generates a cert/key pair signed by the specified parent CA.
func (c *CertKey) Generate(
	cfg *CertCfg,
	parentCA CertKeyInterface,
	filenameBase string,
	appendParent AppendParentChoice,
) error {
	var key *rsa.PrivateKey
	var crt *x509.Certificate
	var err error

	caKey, err := PemToPrivateKey(parentCA.Key())
	if err != nil {
		return errors.Wrap(err, "failed to parse rsa private key")
	}

	caCert, err := PemToCertificate(parentCA.Cert())
	if err != nil {
		return errors.Wrap(err, "failed to parse x509 certificate")
	}

	key, crt, err = GenerateCert(caKey, caCert, cfg)
	if err != nil {
		return errors.Wrap(err, "failed to generate cert/key pair")
	}

	c.keyRaw = PrivateKeyToPem(key)
	c.certRaw = CertToPem(crt)

	if appendParent {
		c.certRaw = bytes.Join([][]byte{c.certRaw, CertToPem(caCert)}, []byte("\n"))
	}

	c.generateFiles(filenameBase)

	return nil
}

// Files returns the files generated by the asset.
func (c *CertKey) Files() []*asset.File {
	return c.files
}

func (c *CertKey) generateFiles(filenameBase string) {
	c.FileList = []*asset.File{
		{
			Filename: assetFilePath(filenameBase + ".key"),
			Data:     c.keyRaw,
		},
		{
			Filename: assetFilePath(filenameBase + ".crt"),
			Data:     c.certRaw,
		},
	}
}

// Load loads cert/key using the fetcher.
func (c *CertKey) Load(filenameBase string, fetcher asset.FileFetcher) (bool, error) {
	var files []*asset.File
	for _, name := range []string{assetFilePath(filenameBase + ".key"), assetFilePath(filenameBase + ".crt")} {
		f, err := fetcher.FetchByName(name)
		if os.IsNotExist(err) {
			return false, nil
		}
		if err != nil {
			return false, err
		}
	}

	c.keyRaw, c.certRaw, c.files = files[0].Data, files[1].Data, files
	return true, nil
}
